---
title: "BUS445 Project"
author: "Team 2"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Data Preparation
## Load Packages & Files and Import the Data

```{r}
# Load Packages
library(tidyverse)
library(car)
library(effects)
library(gplots)
library(mapdata)
library(leaps)
library(rpart)
library(rpart.plot)
library(randomForest)
library(nnet)
library(flexclust)
# Source Files
source("BCA_functions_source_file.R")
# Read in files and keep originals saved
Demographics_original <- read_csv("Telecom Churn CSV dataset/Telco_customer_churn_demographics.csv")
Location_original <- read_csv("Telecom Churn CSV dataset/Telco_customer_churn_location.csv")
Population_original <- read_csv("Telecom Churn CSV dataset/Telco_customer_churn_population.csv")
Services_original <- read_csv("Telecom Churn CSV dataset/Telco_customer_churn_services.csv")
Status_original <- read_csv("Telecom Churn CSV dataset/Telco_customer_churn_status.csv")
```

## Manipulation of the Datasets

```{r}
########################################### RENAME VARIABLES ##############################

Demographics <- rename(Demographics_original, Customer_ID = `Customer ID`, Number_of_Dependents = `Number of Dependents`)
Location <- rename(Location_original, Customer_ID = `Customer ID`, Zip_Code = `Zip Code`, Lat_Long = `Lat Long`)
Population <- rename(Population_original, Zip_Code = `Zip Code`, ZipCode_Population = Population)
Services <- rename(Services_original,  Customer_ID = `Customer ID`, Referred_a_Friend = `Referred a Friend`, Number_of_Referrals = `Number of Referrals`, Tenure_in_Months = `Tenure in Months`, Phone_Service = `Phone Service`, Avg_Monthly_Long_Distance_Charges = `Avg Monthly Long Distance Charges`, Multiple_Lines = `Multiple Lines`, Internet_Service = `Internet Service`, Internet_Type = `Internet Type`, Avg_Monthly_GB_Download = `Avg Monthly GB Download`, Online_Security = `Online Security`, Online_Backup = `Online Backup`, Device_Protection_Plan = `Device Protection Plan`, Premium_Tech_Support = `Premium Tech Support`, Streaming_TV = `Streaming TV`, Streaming_Movies = `Streaming Movies`, Streaming_Music = `Streaming Music`, Unlimited_Data = `Unlimited Data`, Paperless_Billing = `Paperless Billing`, Payment_Method = `Payment Method`, Monthly_Charge = `Monthly Charge`, Total_Charges = `Total Charges`, Total_Refunds = `Total Refunds`, Total_Extra_Data_Charges = `Total Extra Data Charges`, Total_Long_Distance_Charges = `Total Long Distance Charges`, Total_Revenue = `Total Revenue`)
Status <- rename(Status_original, Customer_ID = `Customer ID`, Satisfaction_Score = `Satisfaction Score`, Customer_Status = `Customer Status`, Churn_Label = `Churn Label`, Churn_Value = `Churn Value`, Churn_Category = `Churn Category`, Churn_Reason = `Churn Reason`)

########################################### IMPUTE MISSING VALUES ###########################################

# The missing values (NAs) in the churn category and churn reason columns should have the value of did not churn for the non-churn customers.
filter(filter(Status, Churn_Value == 1), is.na(Churn_Category))
filter(filter(Status, Churn_Value == 1), is.na(Churn_Reason))
# Note: There are no NA values for customers that did churn; all customers provided a reason as to why they left, and all who did not churn have NA values
# So the imputation of all NA values is justified
Status <- mutate(Status, Churn_Category = ifelse(is.na(Churn_Category), "Did Not Churn", Churn_Category), Churn_Reason = ifelse(is.na(Churn_Reason), "Did Not Churn", Churn_Reason))

############################################## VARIABLE CONVERTION (FACTORS) ########################################

Demographics <- mutate(Demographics, Gender = as.factor(Gender), Married = as.factor(Married), Dependents = as.factor(Dependents))
# I'm not going to turn City into a factor as it takes too long and City is not a good predictor from trying it before
Services <- mutate(Services, Quarter = as.factor(Quarter), Referred_a_Friend = as.factor(Referred_a_Friend), Offer = as.factor(Offer), Phone_Service = as.factor(Phone_Service), Multiple_Lines = as.factor(Multiple_Lines), Internet_Service = as.factor(Internet_Service), Internet_Type = as.factor(Internet_Type), Online_Security = as.factor(Online_Security), Online_Backup = as.factor(Online_Backup), Device_Protection_Plan = as.factor(Device_Protection_Plan), Premium_Tech_Support = as.factor(Premium_Tech_Support), Streaming_TV = as.factor(Streaming_TV), Streaming_Movies = as.factor(Streaming_Movies), Streaming_Music = as.factor(Streaming_Music), Unlimited_Data = as.factor(Unlimited_Data), Contract = as.factor(Contract), Paperless_Billing = as.factor(Paperless_Billing), Payment_Method = as.factor(Payment_Method))
Status <- mutate(Status, Quarter = as.factor(Quarter), Customer_Status = as.factor(Customer_Status), Churn_Label = as.factor(Churn_Label), Churn_Category = as.factor(Churn_Category))

########################################### VARIABLE CREATION #########################################

# AGE RANGE VARIABLE
# Binning the ages of customer into a factor variable
Demographics <- mutate(Demographics, 
                       Age_Range = binVariable(Age, bins = 6, method = "intervals", 
                                               labels = c("19-29", "30-39", "40-49", 
                                                          "50-59", "60-69", "70-80"))) %>%
  select(Customer_ID:Age, Age_Range, Married:Number_of_Dependents)

# Add City to Population Dataset
Population <- Population %>% left_join(select(Location, Zip_Code, City), by = "Zip_Code") %>% unique()
# Impute newly created missing values (NA values) in the City column due to the left join property
# We did not have at least one customer in all of the zip codes, so the city values are unknown for some of the zip codes, must insert these values manually.
# Source1: UnitedStatesZipCodes.org -> https://www.unitedstateszipcodes.org/ca/
# Source2: World Population Review.com -> https://worldpopulationreview.com/zips/california
Population[19, "City"] = "Los Angeles"; Population[224, "City"] = "Panorama City"; Population[259, "City"] = "Guasti"; Population[424, "City"] = "Twentynine Palms"; Population[426, "City"] = "Vidal"; 
Population[435, "City"] = "Apple Valley"; Population[444, "City"] = "Blue Jay"; Population[445, "City"] = "Bryn Mawr"; Population[448, "City"] = "Cima"; Population[472, "City"] = "Newberry Springs"; 
Population[483, "City"] = "Tecopa"; Population[654, "City"] = "Delano"; Population[678, "City"] = "Maricopa"; Population[680, "City"] = "Onyx"; Population[693, "City"] = "Tipton"; 
Population[698, "City"] = "Corcoran"; Population[729, "City"] = "Harmony"; Population[738, "City"] = "Paso Robles"; Population[763, "City"] = "Inyokern"; Population[775, "City"] = "Lone Pine"; 
Population[783, "City"] = "Ridgecrest"; Population[786, "City"] = "Trona"; Population[819, "City"] = "Mendota"; Population[864, "City"] = "Big Sur"; Population[1096, "City"] = "Hollister"; 
Population[1159, "City"] = "Altaville"; Population[1246, "City"] = "Westley"; Population[1248, "City"] = "Yosemite National Park"; Population[1259, "City"] = "Camp Meeker"; 
Population[1264, "City"] = "Clearlake Park"; Population[1306, "City"] = "Stewarts Point"; Population[1307, "City"] = "Talmage"; Population[1317, "City"] = "Eureka"; 
Population[1328, "City"] = "Crescent City"; Population[1361, "City"] = "Whitethorn"; Population[1372, "City"] = "Coloma"; Population[1424, "City"] = "Robbins"; Population[1485, "City"] = "Sacramento"; 
Population[1496, "City"] = "Artois"; Population[1543, "City"] = "Rackerby"; Population[1584, "City"] = "Fort Jones"; Population[1592, "City"] = "Hayfork"; Population[1609, "City"] = "Montague"; 
Population[1644, "City"] = "Lake City"; Population[1671, "City"] = "Truckee";

# CITY POPULATION VARIABLE
# Summarize the populations of cities
City_Populations <- Population %>% group_by(City) %>% summarize(City_Population = sum(ZipCode_Population)) %>% arrange(desc(City_Population))
# Add a variable of the population of the cities to the population dataset
Population <- inner_join(Population, City_Populations)

# LARGE CITY VARIABLE
Population <- mutate(Population, LargeCity = as.factor(ifelse(City_Population >= 1500000, "Yes", "No")))

# Add Zip Code, City Population, and Large City Variables to Location dataset for further analysis regarding customer observations
Location <- inner_join(Location, select(Population, Zip_Code, ZipCode_Population, City_Population, LargeCity)) %>% select(Customer_ID:City, City_Population, LargeCity, Zip_Code, ZipCode_Population, Lat_Long:Longitude)

# NEW CUSTOMER VARIABLE
# Creating a factor variable to indicate whether a customer is new or not
Services <- Services %>% mutate(New_Customer = as.factor(ifelse(Tenure_in_Months <= 12, "Yes", "No"))) %>%
  select(Customer_ID:Tenure_in_Months, New_Customer, Offer:Total_Revenue)

# CHURN FACTOR VARIABLE
# Add a factor variable for churn value and keep churn value numeric
Status <- mutate(Status, Churn_Value_Factor = as.factor(Churn_Value)) %>% select(Customer_ID:Churn_Value, Churn_Value_Factor, CLTV:Churn_Reason)

# SATISFACTION LEVEL
# Bin the satisfaction variables into high, medium, and low satisfaction groups
Status <- mutate(Status, Satisfaction_Level = factor(ifelse(Satisfaction_Score < 3, "Low", ifelse(Satisfaction_Score == 3, "Medium", "High")), levels = c("Low", "Medium", "High"))) %>% select(Customer_ID:Satisfaction_Score, Satisfaction_Level, Customer_Status:Churn_Reason)

########################## MAKE A COMPLETE SINGLE TABLE WITH ALL THE VARIABLES ########################

SingleTable <- inner_join(Demographics, Location) %>% inner_join(Services) %>% inner_join(Status) %>% select(Customer_ID:Total_Revenue, CLTV, Satisfaction_Score:Churn_Value_Factor, Churn_Category:Churn_Reason)

# Table that removes variables that are entirely irrelevant to or too complicated for the modeling process
ModelingData <- select(SingleTable, -Customer_ID, -Count, -Country, 
                        -State, -City, -Zip_Code, -Lat_Long,
                        -Quarter, -Customer_Status, -Churn_Category, -Churn_Reason)

#################################### ADD TARGET VARIABLE(S) TO EACH DATASET #################################

Demographics <- inner_join(Demographics, select(Status, Customer_ID, Churn_Value, Churn_Value_Factor))
Location <- inner_join(Location, select(Status, Customer_ID, Churn_Value, Churn_Value_Factor))
Services <- inner_join(Services, select(Status, Customer_ID, Churn_Value, Churn_Value_Factor))

```


## Functions

```{r}
########################################### GRAPHING FUNCTIONS ############################################
# Predictor and Target need to be factors
graph_cat <- function(data, predictor, target) {
  # Bar chart of counts per group
  p1 <- ggplot(data, aes(x = !! sym(predictor))) +
    geom_bar() +
    theme_classic()
  print(p1)
  # Bar chart again but separated by target factor levels
  p2 <- ggplot(data, aes(!!sym(predictor), fill = !!sym(target))) +
    geom_bar(position = "dodge") +
    scale_fill_hue(direction = -1) +
    theme_classic()
  print(p2)
  # Bar chart of proportions regarding target factor levels
  p3 <- ggplot(data, aes(!!sym(predictor), fill = !!sym(target))) +
    geom_bar(position = "fill") +
    scale_fill_hue(direction = -1) +
    theme_classic()
  print(p3)
}
# Predictor needs to be numeric and target needs to be a numeric binary variable
graph_num <- function(data, predictor, target) {
  # Histogram
  p1 <- ggplot(data, aes(!!sym(predictor))) +
    geom_histogram() +
    theme_classic()
  print(p1)
  # Summary Stats
  print(summary(data[[predictor]]))
  # Boxplots
  p2 <- ggplot(data, aes(as.factor(!!sym(target)), !!sym(predictor))) +
    stat_boxplot(geom = "errorbar") + 
    geom_boxplot() +
    xlab(target) +
    theme_classic()
  print(p2)
  # Logistic Graph
  p3 <- ggplot(data, aes(!!sym(predictor), !!sym(target))) +
    geom_jitter() +
    stat_smooth(method="glm", 
              color="forestgreen", 
              se=FALSE, 
              method.args = list(family=binomial)) +
    theme_classic()
  print(p3)
}

############################################## MODELING FUNCTIONS ################################################

# For the following functions, the predictor and target arguments need to be inputted as strings

# Predictor needs to be categorical and target can be a binary numeric or factor
LogitModel_cat <- function(data, predictor, target) {
  model <- glm(formula = paste(target, "~", predictor), 
               data = data, family = binomial(logit))
  print(summary(model))
  print(Anova(model))
}
# Predictor needs to be numeric and target can be a binary numeric or factor
LogitModel_num <- function(data, predictor, target) {
  model <- glm(formula = paste(target, "~", predictor), 
               data = data, family = binomial(logit))
  print(summary(model))
}

# Predictor needs to be categorical and target needs to be a binary factor
explore_cat <- function(data, predictor, target) {
  # The graph_cat needs factors to work with
  graph_cat(data, predictor, target)
  LogitModel_cat(data, predictor, target)
}
# Predictor needs to be numeric and target needs to be a numeric binary
explore_num <- function(data, predictor, target) {
  # graph num needs a numeric predictor and a numeric binary variable
  graph_num(data, predictor, target)
  LogitModel_num(data, predictor, target)
}

# Create a function where you don't have to think about whether the predictor
# is categorical or numeric
explore_variable_churn <- function(data, predictor) {
  if(is.factor(data[[predictor]])) {
    explore_cat(data, predictor, "Churn_Value_Factor")
  }
  if(is.numeric(data[[predictor]])) {
    explore_num(data, predictor, "Churn_Value")
  }
}
# Create a function that will analyze all the desired predictors in a dataset regarding churn
# predictor_list should be a vector of the predictors as strings
analyze_dataset_churn <- function(data, predictor_list) {
  for(predictor in predictor_list) {
    explore_variable_churn(data, predictor)
    print("----------------------------------------------------------------------------------")
  }
}


############################ MISCLASSIFICATION RATE CALCULATION FUNCTIONS ####################################

# TRAINING-VALIDATION SPLIT
# Make a new row in a dataframe to split the data into training and validation observations
training_validation_split <- function(data, seed = 100) {
  data$Set <- create.samples(data, est = 0.75, val = 0.25, rand.seed = seed)
  return(data)
}
# TRAINING DATA
getTrainingData <- function(data) {
  training <- filter(data, Set == "Estimation")
  training <- select(training, -Set)
  return(training)
}
# VALIDATION DATA
getValidationData <- function(data) {
  validation <- filter(data, Set == "Validation")
  validation <- select(validation, -Set)
  return(validation)
}
# TRIAL NAMES
trialnames <- function(trials) {
  trial_names <- c()
  for(i in seq(trials)) {
    trial_names <- c(trial_names, paste("Trial", i))
  }
  return(trial_names)
}
# MATRIX CREATION
# Includes a model for each variable in the predictor list plus an additional spot for the step model
makeMatrix <- function(predictor_list, trials = 1) {
  misclass_matrix <- matrix(nrow = length(predictor_list) + 1, ncol = trials)
  trial_names <- trialnames(trials)
  colnames(misclass_matrix) <- trial_names
  rownames(misclass_matrix) <- c(predictor_list, "Step")
  return(misclass_matrix)
}
# MISCLASSIFICATION RATE
# This is for logistic regression models
getMisclassificationRate <- function(model, actual, newdata) {
  predictions <- round(predict(model, newdata = newdata, type = "response"))
  #print(table(actual, predictions))
  misclassifcation_rate <- mean(predictions != actual)
  return(misclassifcation_rate)
}
# STEP MODEL
makeStepModel <- function(data) {
  initial <- glm(data = data, formula = Churn_Value_Factor ~ 1, family = binomial(logit))
  final <- glm(data = data, 
                formula = Churn_Value_Factor ~ ., family = binomial(logit))
  step_model <- step(object = initial, scope = list(upper = final), k = log(nrow(data)))
  return(step_model)
}
# RUN MODEL
run_model <- function(training_data, predictor) {
  model <- glm(formula = paste("Churn_Value_Factor ~", predictor), 
                     data = training_data, family = binomial(logit))
}
# RUN ALL MODELS
runall_models <- function(data, predictor_list, trials) {
  # Set up matrix
  misclass_matrix <- makeMatrix(predictor_list, trials)
  # Loop for each trial
  for(trial in 1:trials) {
    # Set up
    data <- training_validation_split(data, sample(1:1000000, 1))
    training <- getTrainingData(data)
    validation <- getValidationData(data)
    data <- select(data, -Set)
    actual <- validation$Churn_Value_Factor
    
    # Make a model for each predictor
    for(predictor_index in seq(length(predictor_list))) {
      model <- run_model(training_data = training, predictor = predictor_list[predictor_index])
      misclassification_rate <- getMisclassificationRate(model, actual, newdata = validation)
      misclass_matrix[predictor_index, trial] <- misclassification_rate
    }
    
    # Include step model
    step_model <- makeStepModel(data)
    misclassifcation_rate_step <- getMisclassificationRate(step_model, actual, newdata = validation)
    misclass_matrix[length(predictor_list)+1, trial] <- misclassifcation_rate_step
  }
  return(misclass_matrix)
}

getMeanMisclassificationRates <- function(misclassification_matrix) {
  mean_rates <- c()
  num_rows <- nrow(misclassification_matrix)
  # Loop through each column to get the average rates
  for(r in 1:num_rows) {
    meanrate <- mean(misclassification_matrix[r,])
    mean_rates <- c(mean_rates, meanrate)
  }
  return(mean_rates)
}

makeAverageMisclassTibble <- function(misclassification_matrix) {
  mean_rates <- getMeanMisclassificationRates(misclassification_matrix)
  misMatTibble <- tibble(Model = rownames(misclassification_matrix), Avg_Misclass_Rate = mean_rates)
  misMatTibble <- arrange(misMatTibble, Avg_Misclass_Rate)
  return(misMatTibble)
}

```

# Exploratory Analysis of Datasets

## Demographics Dataset

```{r}
# List of predictors in the Demographics dataset to analyze
predictors_Demographics <- colnames(Demographics)[3:8]
analyze_dataset_churn(Demographics, predictors_Demographics)

########### LOOKING AT SEGMENTATION POSSIBILITIES ########

Age_binned3 <- binVariable(Demographics$Age, bins = 3, method = c("intervals"), labels = c("19-39", "40-59", "60-80"))

Demographics_copy <- mutate(Demographics, Age_Cat = Age_binned3)

Demographics_copy <- mutate(Demographics_copy, Senior = ifelse(Age >= 65, 1, 0))
############## Gender
(Demographics_summary_all <- Demographics %>% group_by(Gender) %>%
    summarize(Total_Count = n(), Proportion = Total_Count / nrow(Demographics)))
(Demographics_summary_Churners <- filter(Demographics, Churn_Value == 1) %>% group_by(Gender) %>%
    summarize(Churn_Count = n(), Proportion = Churn_Count / nrow(Demographics)))
inner_join(select(Demographics_summary_all, -Proportion), select(Demographics_summary_Churners, -Proportion)) %>% mutate(Churn_Rate = Churn_Count/Total_Count)
########### Age Category
(Demographics_summary_all <- Demographics_copy %>% group_by(Age_Cat) %>%
    summarize(Total_Count = n(), Proportion = Total_Count / nrow(Demographics)))
(Demographics_summary_Churners <- filter(Demographics_copy, Churn_Value == 1) %>% group_by(Age_Cat) %>%
    summarize(Churn_Count = n(), Proportion = Churn_Count / nrow(Demographics)))

inner_join(select(Demographics_summary_all, -Proportion), select(Demographics_summary_Churners, -Proportion)) %>% mutate(Churn_Rate = Churn_Count/Total_Count)
############ Senior
(Demographics_summary_all <- Demographics_copy %>% group_by(Senior) %>%
    summarize(Total_Count = n(), Proportion = Total_Count / nrow(Demographics)))
(Demographics_summary_Churners <- filter(Demographics_copy, Churn_Value == 1) %>% group_by(Senior) %>%
    summarize(Churn_Count = n(), Proportion = Churn_Count / nrow(Demographics)))

inner_join(select(Demographics_summary_all, -Proportion), select(Demographics_summary_Churners, -Proportion)) %>% mutate(Churn_Rate = Churn_Count/Total_Count)
################## Married
(Demographics_summary_all <- Demographics %>% group_by(Married) %>%
    summarize(Total_Count = n(), Proportion = Total_Count / nrow(Demographics)))
(Demographics_summary_Churners <- filter(Demographics, Churn_Value == 1) %>% group_by(Married) %>%
    summarize(Churn_Count = n(), Proportion = Churn_Count / nrow(Demographics)))
inner_join(select(Demographics_summary_all, -Proportion), select(Demographics_summary_Churners, -Proportion)) %>% mutate(Churn_Rate = Churn_Count/Total_Count)
################### Dependents
(Demographics_summary_all <- Demographics %>% group_by(Dependents) %>%
    summarize(Total_Count = n(), Proportion = Total_Count / nrow(Demographics)))
(Demographics_summary_Churners <- filter(Demographics, Churn_Value == 1) %>% group_by(Dependents) %>%
    summarize(Churn_Count = n(), Proportion = Churn_Count / nrow(Demographics)))
inner_join(select(Demographics_summary_all, -Proportion), select(Demographics_summary_Churners, -Proportion)) %>% mutate(Churn_Rate = Churn_Count/Total_Count)

################ Demographic Variables
(Demographics_summary_all <- Demographics_copy %>% group_by(Age_Cat, Married, Dependents) %>%
    summarize(Total_Count = n()) %>% arrange(desc(Total_Count)))

Demographics_summary_Churners <- filter(Demographics_copy, Churn_Value == 1) %>% group_by(Age_Cat, Married, Dependents) %>%
    summarize(Churn_Count = n()) %>% arrange(desc(Churn_Count))

Demographics_summary <- inner_join(Demographics_summary_all, Demographics_summary_Churners) %>% mutate(Churn_Rate = Churn_Count / Total_Count) %>% arrange(desc(Total_Count))

Demographics_summary %>% arrange(desc(Churn_Rate))

################ Demographic Variables - Seniors
(Demographics_summary_all <- Demographics_copy %>% group_by(Senior, Married, Dependents) %>%
    summarize(Total_Count = n()) %>% arrange(desc(Total_Count)))

Demographics_summary_Churners <- filter(Demographics_copy, Churn_Value == 1) %>% group_by(Senior, Married, Dependents) %>%
    summarize(Churn_Count = n()) %>% arrange(desc(Churn_Count))

Demographics_summary <- inner_join(Demographics_summary_all, Demographics_summary_Churners) %>% mutate(Churn_Rate = Churn_Count / Total_Count) %>% arrange(desc(Total_Count))

Demographics_summary %>% arrange(desc(Churn_Rate))

explore_cat(Demographics_copy, "Age_Cat", "Churn_Value_Factor")

ggplot(Demographics_copy, aes(Age_Cat, fill = Gender)) +
  geom_bar() +
  theme_classic()

```


## Location Dataset

```{r}
# List of predictors in the Location dataset to analyze
predictors_Location <- colnames(Location)[c(6, 7, 9, 11, 12)]
analyze_dataset_churn(Location, predictors_Location)

###################################################### CITY SUMMARY STATS ########################################################################

# Get counts of customers in each city and the proportions of our total customer base in each city
(City_Summary_Customers <- Location %>% group_by(City) %>% 
  summarize(Number_of_Customers = n(), Proportion_of_Customers = Number_of_Customers / nrow(Location)) %>%
  arrange(desc(Number_of_Customers)))
# Get counts of the number of customer who churned in each city and the proportion of churners in a city out of the total number of churners
(City_Summary_Churners <- filter(Location, Churn_Value == 1) %>% group_by(City) %>%
  summarise(Number_of_Churners = n(), Proportion_of_Total_Churners = Number_of_Churners / nrow(filter(Location, Churn_Value == 1))) %>% arrange(desc(Proportion_of_Total_Churners)))
# We lost most of our customers in San Diego and LA

(ChurnRate_Summary <- inner_join(City_Summary_Customers, City_Summary_Churners) %>% 
    select(City, Number_of_Customers, Number_of_Churners) %>%
    mutate(Churn_Rate = Number_of_Churners / Number_of_Customers) %>% 
    filter(Number_of_Customers > 10) %>%
    arrange(desc(Churn_Rate))) %>% head(10)

(ChurnRate_Summary <- inner_join(City_Summary_Customers, City_Summary_Churners) %>% 
    select(City, Number_of_Customers, Number_of_Churners) %>%
    mutate(Churn_Rate = Number_of_Churners / Number_of_Customers) %>%
    arrange(desc(Number_of_Customers))) %>% head(5)

##################################################### MAPPING OF CUSTOMER LOCATIONS ################################################################

# Map where all our customers are located
ggplot(data = map_data("state", region = "california")) +
  geom_polygon(aes(x = long, y = lat), fill = "white", colour = "black") +
  geom_point(data = Location, mapping = aes(Longitude, Latitude, colour = "Customer"), alpha = 0.06) +
  scale_colour_manual(name = "Legend", breaks = c("Customer"), values = c("Customer" = "purple")) +
  guides(colour = guide_legend(override.aes = list(alpha = 0.7), position = "inside")) +
  coord_fixed() +
  theme_void() +
  theme(legend.position.inside = c(0.8, 0.8)) +
  ggtitle(label = "Map of All Customers") +
  theme(plot.title = element_text(hjust = 0.5))
# Map where our customers churned
ggplot(data = map_data("state", region = "california")) +
  geom_polygon(aes(x = long, y = lat), fill = "white", colour = "black") +
  geom_point(data = filter(Location, Churn_Value == 1), mapping = aes(Longitude, Latitude, colour = "Churned Customer"), 
             alpha = 0.1) +
  scale_color_manual(name = "Legend", breaks = c("Churned Customer"), values = c("Churned Customer" = "red")) +
  guides(colour = guide_legend(override.aes = list(alpha = 0.7), position = "inside")) +
  coord_fixed() +
  theme_void() +
  theme(legend.position = c(0.8, 0.8)) +
  ggtitle(label = "Map of Customers who Churned") +
  theme(plot.title = element_text(hjust = 0.5))
# Plot both churners and non-churners on the same map
ggplot(data = map_data("state", region = "california")) +
  geom_polygon(aes(x = long, y = lat), fill = "white", colour = "black") +
  geom_point(data = filter(Location, Churn_Value == 0), mapping = aes(x=Longitude, y=Latitude, colour = "Stayed Customer"), alpha = 0.2) +
  geom_point(data = filter(Location, Churn_Value == 1), mapping = aes(Longitude, Latitude, colour = "Churned Customer"), alpha = 0.15) +
  scale_color_manual(name = "Legend", breaks = c("Stayed Customer", "Churned Customer"), values = c("Stayed Customer" = "blue", "Churned Customer" = "red")) +
  guides(colour = guide_legend(override.aes = list(alpha = 0.7), position = "inside")) +
  coord_fixed() +
  theme_void() +
  theme(legend.position = c(0.8, 0.8)) +
  ggtitle(label = "Map of Both Customers who Stayed and Churned") +
  theme(plot.title = element_text(hjust = 0.5))

```

## Services Dataset

```{r}
# List of predictors in the Services dataset to analyze
predictors_Services <- colnames(Services)[4:31]
analyze_dataset_churn(Services, predictors_Services)

```


## Status Dataset

```{r}
# List of predictors in the Status dataset to analyze
predictors_Status <- colnames(Status)[c(4, 5, 10)]
analyze_dataset_churn(Status, predictors_Status)

###################################################### COUNTS OF CHURNED CUSTOMERS ##########################################################

(ChurnCount_Summary <- Status %>% select(Customer_ID, Churn_Label) %>% group_by(Churn_Label) %>%
  summarize(Count = n(), Proportion = Count/nrow(Status)))

######################################################## CUSTOMER CHURN REASONS CATEGORIES ##################################################

# Bar chart of counts of customer reasons for churning
ggplot(Status, aes(Churn_Category)) + 
  geom_bar() +
  theme_classic()
# Most customers did not churn

# Same bar chart but only looking at those who did churn
ggplot(filter(Status, Churn_Category != "Did Not Churn"), aes(Churn_Category)) + 
  geom_bar() +
  theme_classic()
# The most common reasons customers churned relates to competitors

(Churn_Category_summary <- filter(Status, Churn_Category != "Did Not Churn") %>% group_by(Churn_Category) %>%
  summarize(Count = n(), Proportion = Count/nrow(filter(Status, Churn_Category != "Did Not Churn")))) %>% arrange(desc(Count))
# Almost half of the customers who churned gave the reason of it being because of competitors

##################################### PIE CHARTS #################################################

pie(c(0.4499732, 0.1680043, 0.1621188, 0.1128946, 0.1070091), c("45%", "17%" , "16%", "11%", "11%"),
    col = c("Blue", "Purple", "Red", "Green", "Grey"),
    main = "Customer Churn Reasons")
legend("topright", c("Competitor", "Attitude", "Dissatisfaction", "Price", "Other"), fill = c("Blue", "Purple", "Red", "Green", "Grey"))

### GGPLOT OF THIS

ggplot(Churn_Category_summary, aes(x="", y=Proportion, fill = Churn_Category)) +
  geom_bar(stat = "identity", width = 1, color="grey") +
  coord_polar("y", start = 0) +
  theme_classic() +
  theme_void() +
  scale_fill_brewer(palette = "Set1") +
  geom_text(y = c(0.06, 0.17, 0.29, 0.63, 0.92), label = c("11.3%", "10.7%", "16.2%", "45.0%", "16.8%"), color = "white", size = 4) +
  ggtitle("Pie Chart of Churn Reasons") +
  theme(plot.title = element_text(hjust = 0.5))

# Removing other from the analysis as most of the other reasons are legitimate reasons
(Churn_Category_summary <- filter(Status, Churn_Category != "Did Not Churn", Churn_Category != "Other") %>% group_by(Churn_Category) %>%
  summarize(Count = n(), Proportion = Count/nrow(filter(Status, Churn_Category != "Did Not Churn", Churn_Category != "Other")))) %>% arrange(desc(Count))

pie(c(0.5038945, 0.1881366, 0.1815458, 0.1264230), c("Competitor", "Attitude" , "Dissatisfaction", "Price"), 
    col = c("Blue", "Purple", "Red", "Green"),
    main = "Customer Churn Reasons - without Other category")
# Over half of are customers were lost because of competitor reasons

###################################################### CUSTOMER TEXT OF REASONS FOR CHURNING ##################################################

(Competitor_Reasons <- Status %>% filter(Churn_Category == "Competitor") %>% group_by(Churn_Reason) %>%
  count() %>% arrange(desc(n)))
# Better devices and/or offers by competitors

(Attitude_Reasons <- Status %>% filter(Churn_Category == "Attitude") %>% group_by(Churn_Reason) %>%
  count() %>% arrange(desc(n)))
# Bad Experience with a support person

(Dissatifaction_Reasons <- Status %>% filter(Churn_Category == "Dissatisfaction") %>% group_by(Churn_Reason) %>%
  count() %>% arrange(desc(n)))
# Product, Network, and Service Dissatisfaction

(Price_Reasons <- Status %>% filter(Churn_Category == "Price") %>% group_by(Churn_Reason) %>%
  count() %>% arrange(desc(n)))
# High prices and/or extra charges

(Other_Reasons <- Status %>% filter(Churn_Category == "Other") %>% group_by(Churn_Reason) %>%
  count() %>% arrange(desc(n)))
# The other category is either legitimate, unhelpful, or unclear

(Table_of_Reasons <- Status %>% filter(Churn_Reason != "Did Not Churn") %>% group_by(Churn_Reason) %>%
  count() %>% arrange(desc(n)))

################################ DATA ON CUSTOMERS WHO JUST JOINED THIS QUARTER ################################

(NewlyJoinedCustomers <- Status %>% group_by(Customer_Status) %>%
   summarise(Count = n(), Proportion = Count / nrow(Status)))

# Data is in Q3
```

# Logistic Regression Models

```{r}

########################################## SET UP MODELING DATAFRAME ############################################

set.seed(136)

# Randomly Sample an even number of churners and non-churners
sample0 <- filter(ModelingData, Churn_Value_Factor == 0) %>% slice_sample(n = 1800)
sample1 <- filter(ModelingData, Churn_Value_Factor == 1) %>% slice_sample(n = 1800)
# Put the two samples into one dataframe and randomly shuffle the rows
ModelingData_ProportionalSample <- bind_rows(sample0, sample1) %>% slice_sample(prop = 1)

# List of predictors to analyze/model
predictor_list <- colnames(ModelingData)[1:42]

# Analyze the sampled dataframe of equal proportions
#analyze_dataset_churn(ModelingData_ProportionalSample, predictor_list)

ModelingData_ProportionalSample <- select(ModelingData_ProportionalSample, -Churn_Value, -Churn_Label)

############################################ MODELLING EACH VARIABLE #####################################

(MisMat <- runall_models(ModelingData_ProportionalSample, predictor_list, 10))
AvgMisMat <- makeAverageMisclassTibble(MisMat)
print(AvgMisMat, n = Inf)

# Can note model has a hit rate of approximately 94%

```

Stepwise Churn Value Logistic Regression Results:

Satisfaction Score + Online Security + Contract + Dependents + Number of Referrals + Referred a Friend + Monthly Charge + New Customer + Zip Code Population

# Step Model for Satisfaction

```{r}

################################# FUNCTIONS ##################################################

makeStepModel_satisfaction <- function(data) {
  initial <- lm(data = data, formula = Satisfaction_Score ~ 1)
  final <- lm(data = data, 
                formula = Satisfaction_Score ~ .)
  step_model <- step(object = initial, scope = list(upper = final), k = log(nrow(data)))
  return(step_model)
}

run_Linearmodel <- function(training_data, predictor) {
  model <- lm(formula = paste("Satisfaction_Score ~", predictor), 
                     data = training_data, family = binomial(logit))
}

MSPE <- function(model, actual, newdata) {
  predictions <- predict(model, newdata = newdata)
  diff = predictions - actual
  diff_sq = diff^2
  mspe <- mean(diff_sq)
  return(mspe)
  
}

runall_models2 <- function(data, predictor_list, trials) {
  # Set up matrix
  mspe_matrix <- makeMatrix(predictor_list, trials)
  # Loop for each trial
  for(trial in 1:trials) {
    # Set up
    data <- training_validation_split(data, sample(1:1000000, 1))
    training <- getTrainingData(data)
    validation <- getValidationData(data)
    data <- select(data, -Set)
    actual <- validation$Satisfaction_Score
    
    # Make a model for each predictor
    for(predictor_index in seq(length(predictor_list))) {
      model <- run_Linearmodel(training_data = training, predictor = predictor_list[predictor_index])
      mspe <- MSPE(model, actual, newdata = validation)
      mspe_matrix[predictor_index, trial] <- mspe
    }
    
    # Include step model
    step_model <- makeStepModel_satisfaction(data)
    mspe_step <- MSPE(step_model, actual, newdata = validation)
    mspe_matrix[length(predictor_list)+1, trial] <- mspe_step
  }
  return(mspe_matrix)
}

makeAverageMSPETibble <- function(mspe_matrix) {
  mean_rates <- getMeanMisclassificationRates(mspe_matrix)
  misMatTibble <- tibble(Model = rownames(mspe_matrix), Avg_MSPE = mean_rates)
  misMatTibble <- arrange(misMatTibble, Avg_MSPE)
  return(misMatTibble)
}

######################################### SATISFACTION VARIABLE #########################################

ggplot(Status, aes(as.factor(Satisfaction_Score), fill = Satisfaction_Level)) +
  geom_bar() +
  xlab("Satisfaction Score") +
  ylab("Count") +
  labs(fill = "Satisfaction Level") +
  theme_classic()

########################################### MODELING #####################################################

set.seed(754)

SatisfactionDataset <- select(SingleTable, -Customer_ID, -Count, -Country, -State, -City, -Zip_Code, -Lat_Long, -Quarter, -Satisfaction_Level, -Customer_Status, -Churn_Label, -Churn_Value, -Churn_Value_Factor, -Churn_Category, -Churn_Reason)
# CONTRACT
ggplot(SatisfactionDataset, aes(Contract, Satisfaction_Score)) + stat_boxplot(geom = "errorbar") + geom_boxplot() + theme_classic()
# INTERNET TYPE
ggplot(SatisfactionDataset, aes(Internet_Service, Satisfaction_Score)) + geom_boxplot() + theme_classic()
ggplot(SingleTable, aes(x=Internet_Service, fill = Satisfaction_Level)) + geom_bar() + theme_classic() + labs(x = "Internet Service", fill = "Satisfaction Level", y = "Count")
ggplot(SatisfactionDataset, aes(Internet_Type, Satisfaction_Score)) + stat_boxplot(geom = "errorbar") + geom_boxplot() + theme_classic()
# TENURE
ggplot(SatisfactionDataset, aes(Tenure_in_Months, Satisfaction_Score)) + geom_point(position = "jitter") + geom_smooth(method = "lm", se = FALSE) + theme_classic()
ggplot(SatisfactionDataset, aes(New_Customer, Satisfaction_Score)) + geom_boxplot() + theme_classic()
# UNLIMITED DATA
ggplot(SatisfactionDataset, aes(Unlimited_Data, Satisfaction_Score)) + geom_boxplot() + theme_classic()

SatisfactionDataset %>% group_by(as.factor(Satisfaction_Score)) %>% summarize(Count = n())
# Lowest count of 518

# Randomly sample to get an equal number of satisfaction values for each score
sample1 <- filter(SatisfactionDataset, Satisfaction_Score == 1) %>% slice_sample(n = 518)
sample2 <- filter(SatisfactionDataset, Satisfaction_Score == 2) %>% slice_sample(n = 518)
sample3 <- filter(SatisfactionDataset, Satisfaction_Score == 3) %>% slice_sample(n = 518)
sample4 <- filter(SatisfactionDataset, Satisfaction_Score == 4) %>% slice_sample(n = 518)
sample5 <- filter(SatisfactionDataset, Satisfaction_Score == 5) %>% slice_sample(n = 518)
# Put the two samples into one dataframe and randomly shuffle the rows
SatisfactionDataset <- bind_rows(sample1, sample2, sample3, sample4, sample5) %>% slice_sample(prop = 1)

predictor_list <- colnames(SatisfactionDataset)[1:32]

MSPE_matrix <- runall_models2(SatisfactionDataset, predictor_list, trials = 10)
AvgMSPEs <- makeAverageMSPETibble(MSPE_matrix)
print(AvgMSPEs, n = Inf)

############################# STEP MODELING ##################################

makeStepModel_satisfaction(SatisfactionDataset)

# Initial Findings: Contract, Online_Security, Number_of_Referrals, Referred_a_Friend, Total_Charges, Dependents, Monthly_Charge, Premium_Tech_Support, Phone_Service, City_Population, LargeCity, Online_Backup, Paperless_Billing

# Remove: 
  # * Number_of_Referrals and Referred_a_Friend --> reverse causation

SatisfactionDataset <- select(SatisfactionDataset, -Number_of_Referrals, -Referred_a_Friend)

makeStepModel_satisfaction(SatisfactionDataset)

# Remove: 
  # * Dependents Variables --> not a controllable variable for us
  # * Population Variables --> not controllable and very small affect
  # * Age --> not controllable + small affect

SatisfactionDataset <- select(SatisfactionDataset, -Dependents, -Number_of_Dependents, -ZipCode_Population, -City_Population, -LargeCity, -Age)

makeStepModel_satisfaction(SatisfactionDataset)

# Results: Contract, Online_Security, Total_Charges, Monthly_Charge, Payment_Method, New_Customer, Phone_Service, Premium_Tech_Support, 
# Avg_Monthly_GB_Download, Tenure_in_Months, Paperless_Billing, Online_Backup
# Major Effects: Contract*, Online_Security
# Some Effect: Monthly_Charge, Payment_Method, New_Customer, Phone_Service, Premium_Tech_Support, Tenure_in_Months*
# Negligible Effects: Total_Charges, Avg_Monthly_GB_Download, Paperless_Billing, Online_Backup

# A fair number of dissatisfied new customers
```

Stepwise Logistic Regression Results for Satisfaction:

Contract + Online Security + New Customer + Payment Method + Premium Tech Support + Monthly Charge + Total Charges + Phone Service


# Final Model to use

```{r}
# Logistic Model Selection - target => Churn:
#                   * Satisfaction Score + Online Security + Contract + Dependents + Number of Referrals + Referred a Friend + Monthly Charge + New Customer + Zip Code Population

set.seed(737)

LiftChartData <- training_validation_split(ModelingData)
LC_TrainingData <- getTrainingData(LiftChartData)
LC_ValidationData <- getValidationData(LiftChartData)
actual <- LC_ValidationData$Churn_Value
LC_TrainingData <- select(LC_TrainingData, -Churn_Value, -Churn_Value_Factor)
LC_ValidationData <- select(LC_ValidationData, -Churn_Value, -Churn_Value_Factor)


################## LOGISTIC REGRESSION MODEL ##############################

LogisticModel <- glm(Churn_Label ~ Satisfaction_Score + Online_Security + Contract + Dependents + Number_of_Referrals + Referred_a_Friend + Monthly_Charge + New_Customer + ZipCode_Population, 
               data = LC_TrainingData, family = binomial(logit))
summary(LogisticModel)

MisclassificationRate = getMisclassificationRate(LogisticModel, actual, newdata = LC_ValidationData)

round((hit_rate = 1 - MisclassificationRate), 4) * 100


################## TREE MODEL ############################################

# FULL TREE MODEL

TreeModel <- rpart(Churn_Label ~ Satisfaction_Score + Contract + Online_Security + Monthly_Charge + Age + Total_Revenue, data = LC_TrainingData, cp = 0.009, model = TRUE)

printcp(TreeModel)
plotcp(TreeModel, upper = "splits")
TreeModel$cptable

rpart.plot(TreeModel, type = 1, extra = 2,
           fallen.leaves = TRUE, uniform = FALSE, digits = 3, 
           yes.text = "true", no.text = "false", cex = 0.7)

Tree_predictions <- round(predict(TreeModel, newdata = LC_ValidationData)[,2])
round(1 -  mean(Tree_predictions != actual), 4) * 100

# SATISFACTION SCORE EQUALS 3

TreeModel_SatEqThree <- rpart(Churn_Label ~ .,
                  data = filter(LC_TrainingData, Satisfaction_Score == 3), cp = 0.05, model = TRUE)

rpart.plot(TreeModel_SatEqThree, type = 1, extra = 2,
           fallen.leaves = TRUE, uniform = FALSE, digits = 3, 
           yes.text = "true", no.text = "false", cex = 0.7)

# NO SATISFACTION IN THE MODEL

TreeModel_noSatisfaction <- rpart(Churn_Label ~ .,
                  data = select(LC_TrainingData, -Satisfaction_Score, -Satisfaction_Level), cp = 0.05, model = TRUE)

rpart.plot(TreeModel_noSatisfaction, type = 1, extra = 2,
           fallen.leaves = TRUE, uniform = FALSE, digits = 3, 
           yes.text = "true", no.text = "false", cex = 0.7)

################## RANDOM FOREST MODEL ##################################

RFModel <- randomForest(formula = Churn_Label ~  Age + Age_Range + 
                          Dependents + Number_of_Dependents + City_Population + 
                          ZipCode_Population + Latitude + Longitude + 
                          Number_of_Referrals + Tenure_in_Months + 
                          New_Customer + Offer + 
                          Avg_Monthly_Long_Distance_Charges + 
                          Internet_Service + Internet_Type + 
                          Avg_Monthly_GB_Download + Online_Security + 
                          Premium_Tech_Support + 
                          Streaming_Music + 
                          Contract + Paperless_Billing + Payment_Method + 
                          Monthly_Charge + Total_Charges + 
                          Total_Long_Distance_Charges + 
                          Total_Revenue + CLTV + Satisfaction_Score + Satisfaction_Level, 
                        data = LC_TrainingData, importance = TRUE, ntree = 2000, mtry = 6)
RFModel
importance(RFModel, type = 2)

# Plot importance
varImpPlot(RFModel,type = 2, main = "Importance Plot")

# Generate Partial Dependence Plot for Satisfaction_Score
partialPlot(RFModel,
            pred.data = data.frame(LC_ValidationData),
            x.var = Satisfaction_Score,
            sub = "Validation Set", # a subtitle
            which.class = "Yes") # target level probability prediction
# Partial Plot function does not work with a tibble

RF_predictions <- round(predict(RFModel, newdata = LC_ValidationData, type = "prob")[, 2])
round(1 -  mean(RF_predictions != actual), 4) * 100

########################### NEURAL NET #########################################

NeuralNet <- Nnet(Churn_Label ~  Age + Age_Range + 
                          Dependents + Number_of_Dependents + City_Population + 
                          ZipCode_Population + Latitude + Longitude + 
                          Number_of_Referrals + Tenure_in_Months + 
                          New_Customer + Offer + 
                          Avg_Monthly_Long_Distance_Charges + 
                          Internet_Service + Internet_Type + 
                          Avg_Monthly_GB_Download + Online_Security + 
                          Premium_Tech_Support + 
                          Streaming_Music + 
                          Contract + Paperless_Billing + Payment_Method + 
                          Monthly_Charge + Total_Charges + 
                          Total_Long_Distance_Charges + 
                          Total_Revenue + CLTV + Satisfaction_Score + Satisfaction_Level,
               data = LC_TrainingData,
               decay = 0.10,
               size = 2)

NeuralNet$value
summary(NeuralNet)

NN_predictions <- round(predict(NeuralNet, newdata = LC_ValidationData))
round(1 -  mean(NN_predictions != actual), 4) * 100


############################ LIFT CHART(s) #####################################

# Validation Cumulative Lift Charts
lift.chart(modelList = c("LogisticModel", "TreeModel", "RFModel", "NeuralNet"),
           data = LC_ValidationData,
           targLevel = "Yes", trueResp = 0.265,
           type = "cumulative", sub = "Validation Set")

lift.chart(modelList = c("LogisticModel"),
           data = LC_ValidationData,
           targLevel = "Yes", trueResp = 0.265,
           type = "cumulative", sub = "Validation Set")


################## HOW DO THE MODELS PERFORM WITHOUT SATISFACTION as a variable???? #####################

initial_noSat <- glm(data = select(LC_TrainingData, -Satisfaction_Score, -Satisfaction_Level), 
               formula = Churn_Label ~ 1, family = binomial(logit))
final_noSat <- glm(data = select(LC_TrainingData, -Satisfaction_Score, -Satisfaction_Level), 
                formula = Churn_Label ~ ., family = binomial(logit))
step_model_noSat <- step(object = initial_noSat, scope = list(upper = final_noSat), 
                         k = log(nrow(LC_TrainingData)))

# Stepwise model results if no Satisfaction: Contract + Internet_Type + Number_of_Referrals + Referred_a_Friend + Dependents + New_Customer + Payment_Method + Age + Streaming_TV + Paperless_Billing + Tenure_in_Months + City_Population + LargeCity + Streaming_Music + Premium_Tech_Support + Online_Security

LogisticModel_noSat <- glm(Churn_Label ~ Contract + Internet_Type + Number_of_Referrals + Referred_a_Friend + Dependents + New_Customer + Payment_Method + Age + Streaming_TV + Paperless_Billing + Tenure_in_Months + City_Population + LargeCity + Streaming_Music + Premium_Tech_Support + Online_Security, 
               data = LC_TrainingData, family = binomial(logit))

MisclassificationRate = getMisclassificationRate(LogisticModel_noSat, actual, newdata = LC_ValidationData)

round((hit_rate = 1 - MisclassificationRate), 4) * 100

summary(LogisticModel_noSat)

######################################

TreeModel_noSat <- rpart(Churn_Label ~ Contract + Age + Number_of_Referrals + Internet_Type,
                  data = select(LC_TrainingData, -Satisfaction_Score, -Satisfaction_Level), cp = 0.053, model = TRUE)

TreeModel_noSat

printcp(TreeModel_noSat)
plotcp(TreeModel_noSat, upper = "splits")
TreeModel_noSat$cptable

Tree_nosat_predictions <- round(predict(TreeModel_noSat, newdata = LC_ValidationData)[,2])
round(1 -  mean(Tree_nosat_predictions != actual), 4) * 100

rpart.plot(TreeModel_noSat, type = 1, extra = 2,
           fallen.leaves = TRUE, uniform = FALSE, digits = 3, 
           yes.text = "true", no.text = "false", cex = 0.7)


RFModel_noSat <- randomForest(Churn_Label ~  Age + Age_Range + 
                          Dependents + Number_of_Dependents + City_Population + 
                          ZipCode_Population + Latitude + Longitude + 
                          Referred_a_Friend + Number_of_Referrals + Tenure_in_Months + 
                          New_Customer + Offer + 
                          Avg_Monthly_Long_Distance_Charges + 
                          Internet_Service + Internet_Type + 
                          Avg_Monthly_GB_Download + Online_Security + 
                          Premium_Tech_Support + 
                          Contract + Paperless_Billing + Payment_Method + 
                          Monthly_Charge + Total_Charges + 
                          Total_Extra_Data_Charges + Total_Long_Distance_Charges + 
                          Total_Revenue + CLTV, 
                        data = LC_TrainingData, importance = TRUE, ntree = 2000, mtry = 6)

importance(RFModel_noSat, type = 2)
varImpPlot(RFModel_noSat,type = 2, main = "Importance Plot")
# Finds that the most important variables are Contract, Monthly_Charge, Tenure_in_Months, Number_of_Referrals

RF_notsat_predictions <- round(predict(RFModel_noSat, newdata = LC_ValidationData, type = "prob")[, 2])
round(1 -  mean(RF_notsat_predictions != actual), 4) * 100



NeuralNet_noSat <- Nnet(Churn_Label ~  Age + Age_Range + 
                          Dependents + Number_of_Dependents + City_Population + 
                          ZipCode_Population + Latitude + Longitude + 
                          Referred_a_Friend + Number_of_Referrals + Tenure_in_Months + 
                          New_Customer + Offer + 
                          Avg_Monthly_Long_Distance_Charges + 
                          Internet_Service + Internet_Type + 
                          Avg_Monthly_GB_Download + Online_Security + 
                          Premium_Tech_Support + 
                          Contract + Paperless_Billing + Payment_Method + 
                          Monthly_Charge + Total_Charges + 
                          Total_Extra_Data_Charges + Total_Long_Distance_Charges + 
                          Total_Revenue + CLTV,
               data = LC_TrainingData,
               decay = 0.10,
               size = 2)

NN_nosat_predictions <- round(predict(NeuralNet_noSat, newdata = LC_ValidationData))

round(1 -  mean(NN_nosat_predictions != actual), 4) * 100





lift.chart(modelList = c("LogisticModel_noSat", "TreeModel_noSat", "RFModel_noSat", "NeuralNet_noSat"),
           data = LC_ValidationData,
           targLevel = "Yes", trueResp = 0.265,
           type = "cumulative", sub = "Validation Set")




```


# New Customers and No Satisfaction

```{r}

set.seed(444)

NewCustomerData_noSat <- filter(ModelingData, New_Customer == "Yes") %>% select(-Satisfaction_Level, -Satisfaction_Score, -New_Customer)

NewCustomerData_noSat <- training_validation_split(NewCustomerData_noSat)

NewCust_TrainingData <- getTrainingData(NewCustomerData_noSat) %>% select(-Churn_Value, -Churn_Value_Factor)

NewCust_ValidationData <- getValidationData(NewCustomerData_noSat)
actual <- NewCust_ValidationData$Churn_Value
NewCust_ValidationData <- select(NewCust_ValidationData, -Churn_Value, -Churn_Value_Factor)


initial_NewCust <- glm(data = NewCust_TrainingData, 
               formula = Churn_Label ~ 1, family = binomial(logit))

final_NewCust <- glm(data = NewCust_TrainingData, 
                     formula = Churn_Label ~ . , 
                     family = binomial(logit))

step_model_NewCust <- step(object = initial_NewCust, scope = list(upper = final_NewCust), 
                         k = log(nrow(NewCust_TrainingData)))

# Stepwise Selection: Internet_Type + Contract + Number_of_Referrals + 
    # Referred_a_Friend + Tenure_in_Months + Payment_Method + Dependents + 
    # Age + Streaming_Music + City_Population + LargeCity + Paperless_Billing

### LOGISTIC REGRESSION MODEL

LogisticModel_NewCust <- glm(Churn_Label ~ Internet_Type + Contract + Number_of_Referrals +  
                               Referred_a_Friend + Tenure_in_Months + Payment_Method + Dependents + 
                               Age + Streaming_Music + City_Population + LargeCity + 
                               Paperless_Billing, 
                             data = NewCust_TrainingData, family = binomial(logit))

MisclassificationRate = getMisclassificationRate(LogisticModel_NewCust, actual, newdata = NewCust_ValidationData)

(hit_rate = 1 - MisclassificationRate)


summary(LogisticModel_NewCust)

################ TREE MODEL

TreeModel_NewCust <- rpart(Churn_Label ~ Internet_Type,
                  data = NewCust_TrainingData, cp = 0.31, model = TRUE)
TreeModel_NewCust
printcp(TreeModel_NewCust)
plotcp(TreeModel_NewCust, upper = "splits")
TreeModel_NewCust$cptable

rpart.plot(TreeModel_NewCust, type = 1, extra = 2,
           fallen.leaves = TRUE, uniform = FALSE, digits = 3, 
           yes.text = "true", no.text = "false", cex = 0.7)

### RANDOM FOREST MODEL

RFModel_NewCust <- randomForest(Churn_Label ~  Age + Age_Range + 
                          Number_of_Dependents + City_Population + 
                          ZipCode_Population + Latitude + Longitude + 
                          Number_of_Referrals + Tenure_in_Months + 
                          Offer + 
                          Avg_Monthly_Long_Distance_Charges + 
                          Internet_Service + Internet_Type + 
                          Avg_Monthly_GB_Download + Online_Security + 
                          Premium_Tech_Support + Streaming_TV + 
                          Streaming_Music + Unlimited_Data + 
                          Contract + Paperless_Billing + Payment_Method + 
                          Monthly_Charge + Total_Charges + 
                          Total_Long_Distance_Charges + 
                          Total_Revenue + CLTV, 
                        data = NewCust_TrainingData, importance = TRUE, ntree = 10000, mtry = 5)
importance(RFModel_NewCust, type = 2)
varImpPlot(RFModel_NewCust,type = 2, main = "Importance Plot")

predictions <- unname(predict(RFModel_NewCust, newdata = NewCust_ValidationData))
predictions <- ifelse(predictions == "Yes", 1, 0)

(hit_rate = 1 - mean(actual != predictions))

### Neural Net Model

NeuralNet_NewCust <- Nnet(Churn_Label ~ Age + Age_Range + 
                          Number_of_Dependents + City_Population + 
                          ZipCode_Population + Latitude + Longitude + 
                          Number_of_Referrals + Tenure_in_Months + 
                          Offer + 
                          Avg_Monthly_Long_Distance_Charges + 
                          Internet_Service + Internet_Type + 
                          Avg_Monthly_GB_Download + Online_Security + 
                          Premium_Tech_Support + Streaming_TV + 
                          Streaming_Music + Unlimited_Data + 
                          Contract + Paperless_Billing + Payment_Method + 
                          Monthly_Charge + Total_Charges + 
                          Total_Long_Distance_Charges + 
                          Total_Revenue + CLTV,
               data = NewCust_TrainingData,
               decay = 0.10,
               size = 4)

### LIFT CHARTS

lift.chart(modelList = c("LogisticModel_NewCust", "RFModel_NewCust"),
           data = LC_ValidationData,
           targLevel = "Yes", trueResp = 0.265,
           type = "cumulative", sub = "Validation Set")


lift.chart(modelList = c("LogisticModel_NewCust", "TreeModel_NewCust", "RFModel_NewCust", "NeuralNet_NewCust"),
           data = LC_ValidationData,
           targLevel = "Yes", trueResp = 0.265,
           type = "cumulative", sub = "Validation Set")

```


# Pricing Schemes - Doesn't really go anywhere or find anything

```{r}

########################## EXPLORING THE RELATIONSHIPS BETWEEN SATISFACTION, INTERNET TYPE, MONTHLY CHARGE, and CONTRACT ###############################################################

ggplot(SingleTable, aes(Satisfaction_Level, Monthly_Charge)) + 
  geom_boxplot() + 
  theme_classic()


ModelingData_copy <- ModelingData %>% mutate(Contract2 = ifelse(Contract == "Month-to-Month", 1, 0))

# Stepwise for Contract

initial <- glm(data = select(ModelingData_copy, -Satisfaction_Score, -Satisfaction_Level, -Churn_Label, -Churn_Value, -Contract, -Churn_Value_Factor), formula = Contract2 ~ 1, family = binomial(logit))

final <- glm(data = select(ModelingData_copy, -Satisfaction_Score, -Satisfaction_Level, -Churn_Label, -Churn_Value, -Churn_Value_Factor, -Contract), 
                     formula = Contract2 ~ . , 
                     family = binomial(logit))

step_model <- step(object = initial, scope = list(upper = final), 
                         k = log(nrow(ModelingData_copy)))

# Result: Tenure_in_Months + Internet_Type + Premium_Tech_Support + 
    # Age_Range + Device_Protection_Plan + Online_Security + Paperless_Billing + 
    # Number_of_Referrals + Payment_Method + Streaming_Movies + 
    # Total_Charges + Streaming_TV + Phone_Service + Monthly_Charge + 
    # Online_Backup

# Graphs:

ggplot(SingleTable, aes(Contract, fill = Satisfaction_Level)) + 
  geom_bar(position = "dodge") + 
  theme_classic()

ggplot(SingleTable, aes(Contract, fill = Internet_Type)) + 
  geom_bar(position = "dodge") + 
  theme_classic()

ggplot(SingleTable, aes(Contract, Monthly_Charge)) + 
  geom_boxplot() + 
  theme_classic()

ggplot(SingleTable, aes(Contract, fill = New_Customer)) + 
  geom_bar(position = "dodge") + 
  theme_classic()

ggplot(SingleTable, aes(Contract, fill = Age_Range)) + 
  geom_bar(position = "dodge") + 
  theme_classic()

ggplot(SingleTable, aes(Contract, fill = Premium_Tech_Support)) + 
  geom_bar(position = "dodge") + 
  theme_classic()

ggplot(SingleTable, aes(Contract, fill = Premium_Tech_Support)) + 
  geom_bar(position = "dodge") + 
  theme_classic()

ggplot(SingleTable, aes(Contract, fill = Age_Range)) + 
  geom_bar(position = "fill") + 
  theme_classic()

ggplot(SingleTable, aes(Contract, Tenure_in_Months)) + 
  geom_boxplot() + 
  theme_classic()

# Stepwise for Internet Type

ModelingData_copy <- ModelingData_copy %>% mutate(Internet_Service2 = ifelse(Internet_Service == "Yes", 1, 0))

initial <- glm(data = select(ModelingData_copy, -Satisfaction_Score, -Satisfaction_Level, -Churn_Label, -Churn_Value, -Churn_Value_Factor, -Internet_Service, -Internet_Type, -Avg_Monthly_GB_Download, -Phone_Service), 
               formula = Internet_Service2 ~ 1, family = binomial(logit))

final <- glm(data = select(ModelingData_copy, -Satisfaction_Score, -Satisfaction_Level, -Churn_Label, -Churn_Value, -Churn_Value_Factor, -Internet_Service, -Internet_Type, -Avg_Monthly_GB_Download, -Phone_Service),
                     formula = Internet_Service2 ~ . , 
                     family = binomial(logit))

step_model <- step(object = initial, scope = list(upper = final), 
                         k = log(nrow(ModelingData_copy)))

# Result: Tenure_in_Months + Internet_Type + Premium_Tech_Support + 
    # Age_Range + Device_Protection_Plan + Online_Security + Paperless_Billing + 
    # Number_of_Referrals + Payment_Method + Streaming_Movies + 
    # Total_Charges + Streaming_TV + Phone_Service + Monthly_Charge + 
    # Online_Backup

# Graphs:

ggplot(ModelingData, aes(Internet_Type, fill=Phone_Service)) +
  geom_bar() +
  theme_classic()

ggplot(ModelingData, aes(Internet_Type, fill=Unlimited_Data)) +
  geom_bar() +
  theme_classic()

ggplot(ModelingData, aes(Internet_Type, Monthly_Charge)) +
  geom_boxplot() +
  theme_classic()

ggplot(ModelingData, aes(Internet_Type, Total_Extra_Data_Charges)) +
  geom_boxplot() +
  theme_classic()

### Stepwise Model for Monthly Charges

initial <- lm(data = select(ModelingData, -Satisfaction_Score, -Satisfaction_Level, -Churn_Label, -Churn_Value, -Churn_Value_Factor, -Total_Charges, -Total_Revenue), formula = Monthly_Charge ~ 1)

final <- lm(data = select(ModelingData, -Satisfaction_Score, -Satisfaction_Level, -Churn_Label, -Churn_Value, -Churn_Value_Factor, -Total_Charges, -Total_Revenue), 
                     formula = Monthly_Charge ~ .)

step_model <- step(object = initial, scope = list(upper = final), 
                         k = log(nrow(ModelingData)))

# Results:  Internet_Type + Streaming_TV + Phone_Service + 
    # Streaming_Movies + Online_Backup + Device_Protection_Plan + 
    # Multiple_Lines + Online_Security + Premium_Tech_Support + 
    # Contract + Age + Payment_Method
# Graphs:

ggplot(ModelingData, aes(Internet_Type, Monthly_Charge, colour = Contract, shape = Churn_Label)) + 
  geom_point(position = "jitter", alpha = 0.75) +
  theme_classic()

ggplot(filter(ModelingData, Internet_Type == "Fiber Optic"), aes(Internet_Type, Monthly_Charge, colour = Contract, shape = Churn_Label)) + 
  geom_point(position = "jitter", alpha = 0.9) +
  theme_classic()

ggplot(ModelingData, aes(Phone_Service, Monthly_Charge)) + 
  geom_point(position = "jitter") +
  theme_classic()

# Indicates two types of customers: Ones that have internet and ones that don't

########################### WHAT IS MONTHLY CHARGE COMPOSED OF ##################
ggplot(ModelingData, aes(Internet_Type, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()
# Definetly Internet Type

ggplot(ModelingData, aes(Streaming_TV, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()
# Not really Streaming_TV

ggplot(ModelingData, aes(Phone_Service, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()
# Hard to tell 

ggplot(ModelingData, aes(Streaming_Movies, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()
# Not really

ggplot(ModelingData, aes(Online_Backup, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()
# Maybe without the online backup less satisfied

ggplot(ModelingData, aes(Device_Protection_Plan, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()
# Maybe without the device protection plan less satisfied

ggplot(ModelingData, aes(Multiple_Lines, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()

ggplot(ModelingData, aes(Online_Backup, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()

ggplot(ModelingData, aes(Online_Security, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()

ggplot(ModelingData, aes(Premium_Tech_Support, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()

ggplot(ModelingData, aes(Contract, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()
# Way more dissatisfaction with Month-to-Month contracts

ggplot(ModelingData, aes(Age, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()

ggplot(ModelingData, aes(Age, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point() +
  geom_smooth() +
  theme_classic()
# People who pay higher amounts are more likely to churn
# Seniors tend to pay more for services, they must have additional something

ggplot(ModelingData, aes(Payment_Method, Monthly_Charge, colour = Satisfaction_Level)) +
  geom_point(position = position_jitterdodge(dodge.width = 0.8), alpha = 0.5) +
  theme_classic()

ggplot(ModelingData, aes(Payment_Method, fill = Satisfaction_Level)) +
  geom_bar(position = "fill") +
  theme_classic()
# Those who pay by credit card are most satisfied

#############################################################################

ggplot(ModelingData, aes(Total_Charges, Monthly_Charge)) + 
  geom_point(position = "jitter") +
  theme_classic()

ggplot(ModelingData, aes(Streaming_TV, Monthly_Charge)) + 
  geom_point(position = "jitter") +
  theme_classic()

########################################################################################


```

# Segmentation - Also a Failure

```{r}
# What should the segmentation variables be?
# Let's try Demographics first

# Need a numeric dataset to cluster on
NumericDataset <- ModelingData %>% select(Age, Number_of_Dependents, City_Population, Number_of_Referrals, Tenure_in_Months, Avg_Monthly_GB_Download, Total_Charges, CLTV, Satisfaction_Score) %>% 
  mutate(Age = scale(Age), Number_of_Dependents = scale(Number_of_Dependents), City_Population = scale(City_Population), Number_of_Referrals = scale(Number_of_Referrals), Tenure_in_Months = scale(Tenure_in_Months), Avg_Monthly_GB_Download = scale(Avg_Monthly_GB_Download), Total_Charges = scale(Total_Charges), CLTV = scale(CLTV), Satisfaction_Score = scale(Satisfaction_Score))

bootCVD(x = NumericDataset,
k = 2:3, # minumum and maximum number of clusters
nboot = 100, # the number of validation sample
nrep = 3, # the number of different sets of random starting centroids
method = "kmn", # "kmn", "kmd", or "neuralgas"
col1 = 'lightblue', col2 = 'orange', dsname = "Demographics")


set.seed(22)

KMeans <- stepFlexclust(NumericDataset,
                        k = 3,
                        nrep = 10,
                        FUN = kcca,
                        family = kccaFamily("kmeans"))

summary(KMeans)

NumericDataset <- mutate(NumericDataset, 
                         Cluster = as.factor(clusters(KMeans)))

# Try PCA

PComp <- prcomp(select(NumericDataset, -Cluster))
summary(PComp)

biplotKmn <- biplot(PComp, xlabs = NumericDataset$Cluster)

```

# Demographic Information - Product and Price are given as reason for leaving in equal amounts (Value in general)

```{r}

SingleTable$Churn_Reason

(Reasons_for_Churning <- Status %>% group_by(Churn_Reason) %>%
  summarize(Count = n()) %>% arrange(desc(Count)))

# Manual Mutaion and should be treated with caution and care
Reasons_for_Churning$Reason = c("Did Not Churn", "Product", "Price", "Service", "Don't Know", "Product", "Product", "Service", "Price", "Product", "Product", "Charges", "Service", "Moved", "Charges", "Product", "Expertise", "Price", "Self-Service", "Expertise", "Died")

Reasons_for_Churning$Reason2 = c("Did Not Churn", "Product", "Price", "Service", "Other", "Product", "Product", "Service", "Price", "Product", "Product", "Other", "Service", "Other", "Other", "Product", "Other", "Price", "Other", "Other", "Other")

Status2 <- Status %>% inner_join(select(Reasons_for_Churning, Churn_Reason, Reason, Reason2), by = "Churn_Reason")

ggplot(filter(Status2, Reason != "Did Not Churn"), aes(Reason)) +
  geom_bar() +
  theme_classic()

SingleTable2 <- SingleTable %>% inner_join(Status2)


ggplot(filter(SingleTable2, Reason != "Did Not Churn", Internet_Type != "None"), aes(Internet_Type, fill = Reason)) +
  geom_bar(position = "dodge") +
  theme_classic()

ggplot(filter(SingleTable2, Reason != "Did Not Churn", Internet_Type != "None"), aes(Contract, fill = Reason)) +
  geom_bar(position = "dodge") +
  theme_classic()

ggplot(filter(SingleTable2, Reason != "Did Not Churn", Internet_Type != "None"), aes(Internet_Type, fill = Reason2)) +
  geom_bar(position = "dodge") +
  theme_classic()

ggplot(filter(SingleTable2, Reason != "Did Not Churn", Internet_Type != "None"), aes(Contract, fill = Reason2)) + 
  geom_bar(position = "dodge") +
  theme_classic()



```


# Answering questions in google doc

```{r}
# Organize average cost per customer per city
SingleTable %>% group_by(City) %>% summarize(Avg_Monthly_Cost = mean(Monthly_Charge)) %>% arrange(desc(Avg_Monthly_Cost)) %>% print(n = 200)
# Table of most customers that provide the most revenue
View(SingleTable %>% arrange(desc(Total_Revenue)) %>% select(Gender, Age, Married, Dependents, City, City_Population, Tenure_in_Months, New_Customer, Phone_Service, Internet_Type, Online_Security, Contract, Payment_Method, Satisfaction_Score, Total_Revenue))

# Checking CLTV
ggplot(mutate(ModelingData, CLTV_cat = binVariable(CLTV, bins = 3, method = "intervals", labels = c("Low", "Medium", "High"))),
       aes(CLTV_cat, fill = Churn_Label)) +
  geom_bar(position = "fill") +
  theme_classic()

# CLTV summary
mutate(ModelingData, CLTV_cat = binVariable(CLTV, bins = 3, method = "intervals", labels = c("Low", "Medium", "High")), Streaming_TV_bi = as.numeric(ifelse(as.character(Streaming_TV) == "Yes", 1, 0)), Streaming_Movies_bi = as.numeric(ifelse(as.character(Streaming_Movies) == "Yes", 1, 0)), Streaming_Music_bi = as.numeric(ifelse(as.character(Streaming_Music) == "Yes", 1, 0)), Internet_bi = as.numeric(ifelse(as.character(Internet_Service) == "Yes", 1, 0)), Phone_bi = as.numeric(ifelse(as.character(Phone_Service) == "Yes", 1, 0)), Dependents_bi = as.numeric(ifelse(as.character(Dependents) == "Yes", 1, 0)), Gender_bi = as.numeric(ifelse(as.character(Gender) == "Female", 1, 0)), FiberOptic_bi = as.numeric(ifelse(as.character(Internet_Type) == "Fiber Optic", 1, 0)), Contract_bi = as.numeric(ifelse(as.character(Contract) == "Month-to-Month", 1, 0))) %>% group_by(CLTV_cat) %>% summarise(Churn_Rate = mean(Churn_Value), Avg_Age = mean(Age), Avg_Revenue = mean(Total_Revenue), Avg_CityPop = mean(City_Population), TV = mean(Streaming_TV_bi), Movies = mean(Streaming_Movies_bi), Music = mean(Streaming_Music_bi), Internet = mean(Internet_bi), Phone = mean(Phone_bi), Dependents = mean(Dependents_bi), Monthly_Charge = mean(Monthly_Charge), Tenure = mean(Tenure_in_Months), Percent_Female = mean(Gender_bi), mean_Sat = mean(Satisfaction_Score), Percent_FiberOptic = mean(FiberOptic_bi), Avg_month_to_month = mean(Contract_bi))


# Total Revenue Summary
mutate(ModelingData, Rev_cat = binVariable(Total_Revenue, bins = 3, method = "intervals", labels = c("Low", "Medium", "High")), Streaming_TV_bi = as.numeric(ifelse(as.character(Streaming_TV) == "Yes", 1, 0)), Streaming_Movies_bi = as.numeric(ifelse(as.character(Streaming_Movies) == "Yes", 1, 0)), Streaming_Music_bi = as.numeric(ifelse(as.character(Streaming_Music) == "Yes", 1, 0)), Internet_bi = as.numeric(ifelse(as.character(Internet_Service) == "Yes", 1, 0)), Phone_bi = as.numeric(ifelse(as.character(Phone_Service) == "Yes", 1, 0)), Dependents_bi = as.numeric(ifelse(as.character(Dependents) == "Yes", 1, 0)), Gender_bi = as.numeric(ifelse(as.character(Gender) == "Female", 1, 0)), FiberOptic_bi = as.numeric(ifelse(as.character(Internet_Type) == "Fiber Optic", 1, 0)), Contract_bi = as.numeric(ifelse(as.character(Contract) == "Month-to-Month", 1, 0))) %>% group_by(Rev_cat) %>% summarise(Churn_Rate = mean(Churn_Value), Avg_Age = mean(Age), Avg_CLTV = mean(CLTV), Avg_CityPop = mean(City_Population), TV = mean(Streaming_TV_bi), Movies = mean(Streaming_Movies_bi), Music = mean(Streaming_Music_bi), Internet = mean(Internet_bi), Phone = mean(Phone_bi), Dependents = mean(Dependents_bi), Monthly_Charge = mean(Monthly_Charge), Tenure = mean(Tenure_in_Months), Percent_Female = mean(Gender_bi), mean_Sat = mean(Satisfaction_Score), Percent_FiberOptic = mean(FiberOptic_bi), Avg_month_to_month = mean(Contract_bi))

# Good Graphs - Churn
ggplot(SingleTable, aes(New_Customer, fill = Churn_Label)) + 
  geom_bar(position = "dodge") +
  scale_fill_hue(direction = -1) +
  theme_classic() +
  ggtitle("Churn Rates of New Customers") +
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("New Customer?") +
  ylab("Percentage of Customers")

# Good Graphs - Satisfaction
ggplot(SatisfactionDataset, aes(Tenure_in_Months, Satisfaction_Score)) + 
  geom_point(position = "jitter") +
  geom_smooth(method = "lm", se = FALSE) +
  theme_classic() +
  ggtitle("Satisfaction over Tenure") +
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("Tenure in Months") +
  ylab("Satisfaction Score")


# Stats
SingleTable %>% group_by(New_Customer) %>% summarise(mean(Churn_Value))

filter(SingleTable, Churn_Value == 1) %>% group_by(New_Customer, Churn_Reason) %>% 
  summarize(Count = n()) %>% arrange(desc(Count)) %>% print(n = Inf)

```

